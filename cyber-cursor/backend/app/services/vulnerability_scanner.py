import re
import ast
import json
import asyncio
from typing import List, Dict, Any, Optional
from pathlib import Path
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    """Comprehensive vulnerability scanner for source code analysis"""
    
    def __init__(self):
        self.vulnerability_patterns = {
            'sql_injection': {
                'patterns': [
                    r'execute\s*\(\s*[\'"][^\'"]*[\'"]\s*\+\s*\w+',
                    r'cursor\.execute\s*\(\s*[\'"][^\'"]*[\'"]\s*%\s*\w+',
                    r'\.execute\s*\(\s*f[\'"][^\'"]*\{\w+\}[^\'"]*[\'"]',
                    r'query\s*=\s*[\'"][^\'"]*[\'"]\s*\+\s*\w+',
                ],
                'severity': 'high',
                'category': 'injection',
                'description': 'SQL Injection vulnerability detected'
            },
            'xss': {
                'patterns': [
                    r'innerHTML\s*=\s*\w+',
                    r'outerHTML\s*=\s*\w+',
                    r'document\.write\s*\(\s*\w+',
                    r'\.html\s*\(\s*\w+',
                    r'\.append\s*\(\s*\w+',
                ],
                'severity': 'high',
                'category': 'xss',
                'description': 'Cross-Site Scripting (XSS) vulnerability detected'
            },
            'command_injection': {
                'patterns': [
                    r'os\.system\s*\(\s*\w+',
                    r'subprocess\.call\s*\(\s*\w+',
                    r'subprocess\.Popen\s*\(\s*\w+',
                    r'exec\s*\(\s*\w+',
                    r'eval\s*\(\s*\w+',
                ],
                'severity': 'critical',
                'category': 'injection',
                'description': 'Command injection vulnerability detected'
            },
            'path_traversal': {
                'patterns': [
                    r'open\s*\(\s*\w+',
                    r'file\s*\(\s*\w+',
                    r'Path\s*\(\s*\w+',
                    r'\.read\s*\(\s*\w+',
                ],
                'severity': 'medium',
                'category': 'path_traversal',
                'description': 'Path traversal vulnerability detected'
            },
            'hardcoded_credentials': {
                'patterns': [
                    r'password\s*=\s*[\'"][^\'"]+[\'"]',
                    r'secret\s*=\s*[\'"][^\'"]+[\'"]',
                    r'api_key\s*=\s*[\'"][^\'"]+[\'"]',
                    r'token\s*=\s*[\'"][^\'"]+[\'"]',
                ],
                'severity': 'high',
                'category': 'credentials',
                'description': 'Hardcoded credentials detected'
            },
            'weak_crypto': {
                'patterns': [
                    r'md5\s*\(',
                    r'sha1\s*\(',
                    r'hashlib\.md5',
                    r'hashlib\.sha1',
                ],
                'severity': 'medium',
                'category': 'cryptography',
                'description': 'Weak cryptographic algorithm detected'
            },
            'insecure_deserialization': {
                'patterns': [
                    r'pickle\.loads\s*\(',
                    r'yaml\.load\s*\(',
                    r'json\.loads\s*\(\s*\w+',
                ],
                'severity': 'high',
                'category': 'deserialization',
                'description': 'Insecure deserialization detected'
            },
            'missing_authentication': {
                'patterns': [
                    r'@app\.route\s*\(\s*[\'"][^\'"]*[\'"]\s*\)',
                    r'@router\.get\s*\(\s*[\'"][^\'"]*[\'"]\s*\)',
                    r'@router\.post\s*\(\s*[\'"][^\'"]*[\'"]\s*\)',
                ],
                'severity': 'medium',
                'category': 'authentication',
                'description': 'Missing authentication on endpoint'
            },
            'cors_misconfiguration': {
                'patterns': [
                    r'CORS\s*\(\s*allow_origins\s*=\s*[\'"][*][\'"]',
                    r'Access-Control-Allow-Origin\s*:\s*[\'"][*][\'"]',
                ],
                'severity': 'medium',
                'category': 'cors',
                'description': 'CORS misconfiguration detected'
            },
            'debug_mode': {
                'patterns': [
                    r'debug\s*=\s*True',
                    r'DEBUG\s*=\s*True',
                    r'development\s*=\s*True',
                ],
                'severity': 'low',
                'category': 'configuration',
                'description': 'Debug mode enabled in production code'
            }
        }
        
        self.language_extensions = {
            'python': ['.py'],
            'javascript': ['.js', '.jsx', '.ts', '.tsx'],
            'java': ['.java'],
            'php': ['.php'],
            'ruby': ['.rb'],
            'go': ['.go'],
            'rust': ['.rs'],
            'csharp': ['.cs'],
            'cpp': ['.cpp', '.cc', '.cxx'],
            'c': ['.c'],
            'html': ['.html', '.htm'],
            'css': ['.css'],
            'xml': ['.xml'],
            'json': ['.json'],
            'yaml': ['.yml', '.yaml'],
            'shell': ['.sh', '.bash', '.zsh'],
            'powershell': ['.ps1'],
            'batch': ['.bat', '.cmd']
        }
    
    async def scan_file(self, file_path: str, language: str = None) -> List[Dict[str, Any]]:
        """Scan a single file for vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Determine language from file extension if not provided
            if not language:
                language = self._detect_language(file_path)
            
            # Read file content
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # Scan for patterns
            for vuln_type, vuln_info in self.vulnerability_patterns.items():
                for pattern in vuln_info['patterns']:
                    matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
                    for match in matches:
                        line_number = content[:match.start()].count('\n') + 1
                        line_content = content.split('\n')[line_number - 1].strip()
                        
                        vulnerability = {
                            'type': vuln_type,
                            'severity': vuln_info['severity'],
                            'category': vuln_info['category'],
                            'description': vuln_info['description'],
                            'file_path': file_path,
                            'line_number': line_number,
                            'line_content': line_content,
                            'match': match.group(),
                            'language': language,
                            'detected_at': datetime.utcnow().isoformat()
                        }
                        vulnerabilities.append(vulnerability)
            
            # Language-specific analysis
            if language == 'python':
                vulnerabilities.extend(await self._analyze_python_file(file_path, content))
            elif language in ['javascript', 'typescript']:
                vulnerabilities.extend(await self._analyze_javascript_file(file_path, content))
            elif language == 'java':
                vulnerabilities.extend(await self._analyze_java_file(file_path, content))
            
        except Exception as e:
            logger.error(f"Error scanning file {file_path}: {e}")
        
        return vulnerabilities
    
    async def scan_directory(self, directory_path: str) -> Dict[str, Any]:
        """Scan an entire directory for vulnerabilities"""
        scan_results = {
            'total_files': 0,
            'scanned_files': 0,
            'vulnerabilities': [],
            'summary': {
                'critical': 0,
                'high': 0,
                'medium': 0,
                'low': 0
            },
            'scan_started_at': datetime.utcnow().isoformat(),
            'scan_completed_at': None
        }
        
        try:
            directory = Path(directory_path)
            if not directory.exists():
                raise ValueError(f"Directory {directory_path} does not exist")
            
            # Get all files to scan
            files_to_scan = []
            for ext_list in self.language_extensions.values():
                for ext in ext_list:
                    files_to_scan.extend(directory.rglob(f"*{ext}"))
            
            scan_results['total_files'] = len(files_to_scan)
            
            # Scan each file
            for file_path in files_to_scan:
                try:
                    language = self._detect_language(str(file_path))
                    file_vulns = await self.scan_file(str(file_path), language)
                    scan_results['vulnerabilities'].extend(file_vulns)
                    scan_results['scanned_files'] += 1
                except Exception as e:
                    logger.error(f"Error scanning {file_path}: {e}")
            
            # Calculate summary
            for vuln in scan_results['vulnerabilities']:
                severity = vuln['severity']
                if severity in scan_results['summary']:
                    scan_results['summary'][severity] += 1
            
            scan_results['scan_completed_at'] = datetime.utcnow().isoformat()
            
        except Exception as e:
            logger.error(f"Error scanning directory {directory_path}: {e}")
            raise
        
        return scan_results
    
    def _detect_language(self, file_path: str) -> str:
        """Detect programming language from file extension"""
        file_ext = Path(file_path).suffix.lower()
        
        for language, extensions in self.language_extensions.items():
            if file_ext in extensions:
                return language
        
        return 'unknown'
    
    async def _analyze_python_file(self, file_path: str, content: str) -> List[Dict[str, Any]]:
        """Python-specific vulnerability analysis"""
        vulnerabilities = []
        
        try:
            # Parse AST for deeper analysis
            tree = ast.parse(content)
            
            for node in ast.walk(tree):
                # Check for dangerous function calls
                if isinstance(node, ast.Call):
                    if isinstance(node.func, ast.Name):
                        func_name = node.func.id
                        if func_name in ['eval', 'exec', 'input']:
                            vulnerability = {
                                'type': 'dangerous_function',
                                'severity': 'high',
                                'category': 'injection',
                                'description': f'Dangerous function {func_name} detected',
                                'file_path': file_path,
                                'line_number': node.lineno,
                                'line_content': content.split('\n')[node.lineno - 1].strip(),
                                'match': func_name,
                                'language': 'python',
                                'detected_at': datetime.utcnow().isoformat()
                            }
                            vulnerabilities.append(vulnerability)
                
                # Check for hardcoded secrets in assignments
                if isinstance(node, ast.Assign):
                    for target in node.targets:
                        if isinstance(target, ast.Name):
                            var_name = target.id.lower()
                            if any(secret_word in var_name for secret_word in ['password', 'secret', 'key', 'token']):
                                if isinstance(node.value, ast.Str):
                                    vulnerability = {
                                        'type': 'hardcoded_secret',
                                        'severity': 'high',
                                        'category': 'credentials',
                                        'description': f'Hardcoded secret in variable {var_name}',
                                        'file_path': file_path,
                                        'line_number': node.lineno,
                                        'line_content': content.split('\n')[node.lineno - 1].strip(),
                                        'match': var_name,
                                        'language': 'python',
                                        'detected_at': datetime.utcnow().isoformat()
                                    }
                                    vulnerabilities.append(vulnerability)
        
        except SyntaxError:
            # File has syntax errors, skip AST analysis
            pass
        except Exception as e:
            logger.error(f"Error in Python AST analysis for {file_path}: {e}")
        
        return vulnerabilities
    
    async def _analyze_javascript_file(self, file_path: str, content: str) -> List[Dict[str, Any]]:
        """JavaScript-specific vulnerability analysis"""
        vulnerabilities = []
        
        # Check for dangerous patterns
        dangerous_patterns = [
            (r'eval\s*\(\s*[\'"][^\'"]*[\'"]', 'eval_usage', 'high'),
            (r'innerHTML\s*=\s*[\'"][^\'"]*[\'"]', 'innerhtml_assignment', 'high'),
            (r'localStorage\.setItem\s*\(\s*[\'"][^\'"]*[\'"]', 'localstorage_usage', 'medium'),
            (r'sessionStorage\.setItem\s*\(\s*[\'"][^\'"]*[\'"]', 'sessionstorage_usage', 'medium'),
        ]
        
        for pattern, vuln_type, severity in dangerous_patterns:
            matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
            for match in matches:
                line_number = content[:match.start()].count('\n') + 1
                line_content = content.split('\n')[line_number - 1].strip()
                
                vulnerability = {
                    'type': vuln_type,
                    'severity': severity,
                    'category': 'javascript_security',
                    'description': f'JavaScript security issue: {vuln_type}',
                    'file_path': file_path,
                    'line_number': line_number,
                    'line_content': line_content,
                    'match': match.group(),
                    'language': 'javascript',
                    'detected_at': datetime.utcnow().isoformat()
                }
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    async def _analyze_java_file(self, file_path: str, content: str) -> List[Dict[str, Any]]:
        """Java-specific vulnerability analysis"""
        vulnerabilities = []
        
        # Check for dangerous patterns
        dangerous_patterns = [
            (r'Runtime\.getRuntime\(\)\.exec\s*\(\s*[\'"][^\'"]*[\'"]', 'command_execution', 'critical'),
            (r'ProcessBuilder\s*\(\s*[\'"][^\'"]*[\'"]', 'process_builder', 'high'),
            (r'\.executeQuery\s*\(\s*[\'"][^\'"]*[\'"]', 'sql_query', 'medium'),
        ]
        
        for pattern, vuln_type, severity in dangerous_patterns:
            matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
            for match in matches:
                line_number = content[:match.start()].count('\n') + 1
                line_content = content.split('\n')[line_number - 1].strip()
                
                vulnerability = {
                    'type': vuln_type,
                    'severity': severity,
                    'category': 'java_security',
                    'description': f'Java security issue: {vuln_type}',
                    'file_path': file_path,
                    'line_number': line_number,
                    'line_content': line_content,
                    'match': match.group(),
                    'language': 'java',
                    'detected_at': datetime.utcnow().isoformat()
                }
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def generate_report(self, scan_results: Dict[str, Any]) -> Dict[str, Any]:
        """Generate a comprehensive vulnerability report"""
        report = {
            'scan_info': {
                'started_at': scan_results['scan_started_at'],
                'completed_at': scan_results['scan_completed_at'],
                'total_files': scan_results['total_files'],
                'scanned_files': scan_results['scanned_files'],
                'scan_duration': None
            },
            'vulnerability_summary': scan_results['summary'],
            'vulnerabilities_by_severity': {},
            'vulnerabilities_by_category': {},
            'vulnerabilities_by_language': {},
            'recommendations': [],
            'risk_score': 0
        }
        
        # Calculate scan duration
        if scan_results['scan_started_at'] and scan_results['scan_completed_at']:
            start_time = datetime.fromisoformat(scan_results['scan_started_at'])
            end_time = datetime.fromisoformat(scan_results['scan_completed_at'])
            duration = (end_time - start_time).total_seconds()
            report['scan_info']['scan_duration'] = f"{duration:.2f} seconds"
        
        # Group vulnerabilities by severity
        for vuln in scan_results['vulnerabilities']:
            severity = vuln['severity']
            if severity not in report['vulnerabilities_by_severity']:
                report['vulnerabilities_by_severity'][severity] = []
            report['vulnerabilities_by_severity'][severity].append(vuln)
        
        # Group vulnerabilities by category
        for vuln in scan_results['vulnerabilities']:
            category = vuln['category']
            if category not in report['vulnerabilities_by_category']:
                report['vulnerabilities_by_category'][category] = []
            report['vulnerabilities_by_category'][category].append(vuln)
        
        # Group vulnerabilities by language
        for vuln in scan_results['vulnerabilities']:
            language = vuln['language']
            if language not in report['vulnerabilities_by_language']:
                report['vulnerabilities_by_language'][language] = []
            report['vulnerabilities_by_language'][language].append(vuln)
        
        # Calculate risk score (weighted by severity)
        severity_weights = {'critical': 10, 'high': 7, 'medium': 4, 'low': 1}
        total_score = 0
        total_vulns = len(scan_results['vulnerabilities'])
        
        for vuln in scan_results['vulnerabilities']:
            weight = severity_weights.get(vuln['severity'], 1)
            total_score += weight
        
        if total_vulns > 0:
            report['risk_score'] = total_score / total_vulns
        
        # Generate recommendations
        recommendations = []
        if scan_results['summary']['critical'] > 0:
            recommendations.append("Immediate action required: Critical vulnerabilities detected")
        if scan_results['summary']['high'] > 0:
            recommendations.append("High priority: Address high severity vulnerabilities")
        if scan_results['summary']['sql_injection'] > 0:
            recommendations.append("Use parameterized queries to prevent SQL injection")
        if scan_results['summary']['xss'] > 0:
            recommendations.append("Implement proper input validation and output encoding")
        
        report['recommendations'] = recommendations
        
        return report 