{"ast":null,"code":"import axios from 'axios';\n\n// Create axios instance with default configuration\nconst apiClient = axios.create({\n  baseURL: process.env.REACT_APP_API_URL || 'http://localhost:8000',\n  timeout: 30000,\n  // Increased timeout for complex operations\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n\n// Request interceptor to add auth token\napiClient.interceptors.request.use(config => {\n  const token = localStorage.getItem('authToken');\n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  return config;\n}, error => {\n  return Promise.reject(error);\n});\n\n// Response interceptor to handle errors\napiClient.interceptors.response.use(response => {\n  return response;\n}, async error => {\n  var _error$response, _error$response2, _error$response3, _error$response4;\n  const originalRequest = error.config;\n  if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401 && originalRequest) {\n    // Handle unauthorized access\n    const refreshToken = localStorage.getItem('refreshToken');\n    if (refreshToken) {\n      try {\n        // Try to refresh the token\n        const response = await axios.post('/auth/refresh', {\n          refresh_token: refreshToken\n        });\n        const {\n          access_token\n        } = response.data;\n        localStorage.setItem('authToken', access_token);\n\n        // Retry the original request\n        originalRequest.headers.Authorization = `Bearer ${access_token}`;\n        return apiClient(originalRequest);\n      } catch (refreshError) {\n        // Refresh failed, redirect to login\n        localStorage.removeItem('authToken');\n        localStorage.removeItem('refreshToken');\n        window.location.href = '/login';\n      }\n    } else {\n      // No refresh token, redirect to login\n      localStorage.removeItem('authToken');\n      window.location.href = '/login';\n    }\n  }\n\n  // Handle other errors\n  if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 403) {\n    console.error('Access forbidden');\n  } else if (((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) === 404) {\n    console.error('Resource not found');\n  } else if (((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status) === 500) {\n    console.error('Internal server error');\n  }\n  return Promise.reject(error);\n});\n\n// Helper function for API calls with retry logic\nexport const apiCallWithRetry = async (apiCall, maxRetries = 3, delay = 1000) => {\n  let lastError;\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      return await apiCall();\n    } catch (error) {\n      var _error$response5, _error$response6;\n      lastError = error;\n\n      // Don't retry on client errors (4xx)\n      if (((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : _error$response5.status) >= 400 && ((_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : _error$response6.status) < 500) {\n        throw error;\n      }\n      if (attempt < maxRetries) {\n        await new Promise(resolve => setTimeout(resolve, delay * attempt));\n      }\n    }\n  }\n  throw lastError;\n};\nexport { apiClient };","map":{"version":3,"names":["axios","apiClient","create","baseURL","process","env","REACT_APP_API_URL","timeout","headers","interceptors","request","use","config","token","localStorage","getItem","Authorization","error","Promise","reject","response","_error$response","_error$response2","_error$response3","_error$response4","originalRequest","status","refreshToken","post","refresh_token","access_token","data","setItem","refreshError","removeItem","window","location","href","console","apiCallWithRetry","apiCall","maxRetries","delay","lastError","attempt","_error$response5","_error$response6","resolve","setTimeout"],"sources":["D:/curser/copy-of-git-10-082025/cyber-cursor/frontend/src/utils/apiClient.ts"],"sourcesContent":["import axios, { AxiosError, AxiosResponse } from 'axios';\r\n\r\n// Create axios instance with default configuration\r\nconst apiClient = axios.create({\r\n  baseURL: process.env.REACT_APP_API_URL || 'http://localhost:8000',\r\n  timeout: 30000, // Increased timeout for complex operations\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n  },\r\n});\r\n\r\n// Request interceptor to add auth token\r\napiClient.interceptors.request.use(\r\n  (config) => {\r\n    const token = localStorage.getItem('authToken');\r\n    if (token) {\r\n      config.headers.Authorization = `Bearer ${token}`;\r\n    }\r\n    return config;\r\n  },\r\n  (error) => {\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// Response interceptor to handle errors\r\napiClient.interceptors.response.use(\r\n  (response: AxiosResponse) => {\r\n    return response;\r\n  },\r\n  async (error: AxiosError) => {\r\n    const originalRequest = error.config;\r\n    \r\n    if (error.response?.status === 401 && originalRequest) {\r\n      // Handle unauthorized access\r\n      const refreshToken = localStorage.getItem('refreshToken');\r\n      \r\n      if (refreshToken) {\r\n        try {\r\n          // Try to refresh the token\r\n          const response = await axios.post('/auth/refresh', {\r\n            refresh_token: refreshToken\r\n          });\r\n          \r\n          const { access_token } = response.data;\r\n          localStorage.setItem('authToken', access_token);\r\n          \r\n          // Retry the original request\r\n          originalRequest.headers.Authorization = `Bearer ${access_token}`;\r\n          return apiClient(originalRequest);\r\n        } catch (refreshError) {\r\n          // Refresh failed, redirect to login\r\n          localStorage.removeItem('authToken');\r\n          localStorage.removeItem('refreshToken');\r\n          window.location.href = '/login';\r\n        }\r\n      } else {\r\n        // No refresh token, redirect to login\r\n        localStorage.removeItem('authToken');\r\n        window.location.href = '/login';\r\n      }\r\n    }\r\n    \r\n    // Handle other errors\r\n    if (error.response?.status === 403) {\r\n      console.error('Access forbidden');\r\n    } else if (error.response?.status === 404) {\r\n      console.error('Resource not found');\r\n    } else if (error.response?.status === 500) {\r\n      console.error('Internal server error');\r\n    }\r\n    \r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// Helper function for API calls with retry logic\r\nexport const apiCallWithRetry = async <T>(\r\n  apiCall: () => Promise<T>,\r\n  maxRetries: number = 3,\r\n  delay: number = 1000\r\n): Promise<T> => {\r\n  let lastError: any;\r\n  \r\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n    try {\r\n      return await apiCall();\r\n    } catch (error: any) {\r\n      lastError = error;\r\n      \r\n      // Don't retry on client errors (4xx)\r\n      if (error.response?.status >= 400 && error.response?.status < 500) {\r\n        throw error;\r\n      }\r\n      \r\n      if (attempt < maxRetries) {\r\n        await new Promise(resolve => setTimeout(resolve, delay * attempt));\r\n      }\r\n    }\r\n  }\r\n  \r\n  throw lastError;\r\n};\r\n\r\nexport { apiClient }; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}