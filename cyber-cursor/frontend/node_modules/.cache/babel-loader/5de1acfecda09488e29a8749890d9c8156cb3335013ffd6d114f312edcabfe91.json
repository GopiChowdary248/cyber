{"ast":null,"code":"import { apiClient, apiCallWithRetry } from '../utils/apiClient';\nimport { API_ENDPOINTS, SERVICE_MAPPING } from './integrationService';\n\n// Integration verification interfaces\n\nclass IntegrationVerificationService {\n  constructor() {\n    this.verificationResults = new Map();\n    this.isVerifying = false;\n  }\n  /**\n   * Verify all service integrations comprehensively\n   */\n  async verifyAllIntegrations() {\n    if (this.isVerifying) {\n      throw new Error('Verification already in progress');\n    }\n    this.isVerifying = true;\n    const startTime = Date.now();\n    try {\n      const services = Object.values(SERVICE_MAPPING);\n      const serviceResults = [];\n      for (const serviceName of services) {\n        const serviceStatus = await this.verifyServiceIntegration(serviceName);\n        serviceResults.push(serviceStatus);\n        this.verificationResults.set(serviceName, serviceStatus);\n      }\n      const report = this.generateIntegrationReport(serviceResults, startTime);\n      return report;\n    } finally {\n      this.isVerifying = false;\n    }\n  }\n\n  /**\n   * Verify integration for a specific service\n   */\n  async verifyServiceIntegration(serviceName) {\n    const endpoints = this.getServiceEndpoints(serviceName);\n    const endpointResults = [];\n    for (const [endpointName, endpoint] of Object.entries(endpoints)) {\n      try {\n        const result = await this.testEndpoint(endpoint, endpointName);\n        endpointResults.push(result);\n      } catch (error) {\n        endpointResults.push({\n          endpoint: endpointName,\n          method: 'GET',\n          status: 'failed',\n          responseTime: 0,\n          error: error instanceof Error ? error.message : 'Unknown error'\n        });\n      }\n    }\n    const successCount = endpointResults.filter(r => r.status === 'success').length;\n    const successRate = successCount / endpointResults.length * 100;\n    const averageResponseTime = endpointResults.filter(r => r.responseTime > 0).reduce((sum, r) => sum + r.responseTime, 0) / successCount || 0;\n    const overallStatus = successRate >= 90 ? 'healthy' : successRate >= 50 ? 'partial' : 'unhealthy';\n    return {\n      service: serviceName,\n      endpoints: endpointResults,\n      overallStatus,\n      successRate,\n      averageResponseTime,\n      lastVerified: new Date()\n    };\n  }\n\n  /**\n   * Test a specific endpoint\n   */\n  async testEndpoint(endpoint, endpointName) {\n    const startTime = Date.now();\n    let status = 'success';\n    let statusCode;\n    let error;\n    let response;\n    try {\n      // Handle dynamic endpoints with IDs\n      const actualEndpoint = typeof endpoint === 'function' ? endpoint('test-id') : endpoint;\n\n      // Test with GET method first, fallback to POST for endpoints that require it\n      try {\n        const result = await apiCallWithRetry(() => apiClient.get(actualEndpoint, {\n          timeout: 10000\n        }));\n        statusCode = result.status;\n        response = result.data;\n      } catch (getError) {\n        var _getError$response;\n        if (((_getError$response = getError.response) === null || _getError$response === void 0 ? void 0 : _getError$response.status) === 405) {\n          // Method not allowed, try POST\n          try {\n            const result = await apiCallWithRetry(() => apiClient.post(actualEndpoint, {}, {\n              timeout: 10000\n            }));\n            statusCode = result.status;\n            response = result.data;\n          } catch (postError) {\n            throw postError;\n          }\n        } else {\n          throw getError;\n        }\n      }\n      if (statusCode >= 400) {\n        status = 'failed';\n        error = `HTTP ${statusCode}`;\n      }\n    } catch (err) {\n      var _err$response;\n      if (err.code === 'ECONNABORTED') {\n        status = 'timeout';\n        error = 'Request timeout';\n      } else if (((_err$response = err.response) === null || _err$response === void 0 ? void 0 : _err$response.status) === 401) {\n        status = 'unauthorized';\n        error = 'Unauthorized access';\n      } else {\n        status = 'failed';\n        error = err.message || 'Request failed';\n      }\n    }\n    const responseTime = Date.now() - startTime;\n    return {\n      endpoint: endpointName,\n      method: 'GET',\n      status,\n      responseTime,\n      statusCode,\n      error,\n      response\n    };\n  }\n\n  /**\n   * Get all endpoints for a specific service\n   */\n  getServiceEndpoints(serviceName) {\n    // Map service names to their corresponding API endpoint groups\n    const serviceEndpointMap = {\n      'sastService': 'SAST',\n      'dastService': 'DAST',\n      'raspService': 'RASP',\n      'cloudSecurityService': 'CLOUD_SECURITY',\n      'enhancedCloudSecurityService': 'ENHANCED_CLOUD_SECURITY',\n      'networkSecurityService': 'NETWORK_SECURITY',\n      'endpointSecurityService': 'ENDPOINT_SECURITY',\n      'endpointAntivirusEdrService': 'ENDPOINT_ANTIVIRUS_EDR',\n      'deviceControlService': 'DEVICE_CONTROL',\n      'dataSecurityService': 'DATA_SECURITY',\n      'dataProtectionService': 'DATA_PROTECTION',\n      'siemSoarService': 'SIEM_SOAR',\n      'monitoringSiemSoarService': 'MONITORING_SIEM_SOAR',\n      'analyticsService': 'ANALYTICS',\n      'threatIntelligenceService': 'THREAT_INTELLIGENCE',\n      'complianceService': 'COMPLIANCE',\n      'qualityGoalsService': 'QUALITY_GOALS',\n      'workflowsService': 'WORKFLOWS',\n      'incidentService': 'INCIDENTS',\n      'phishingService': 'PHISHING',\n      'cicdService': 'CICD',\n      'integrationsService': 'INTEGRATIONS',\n      'dashboardService': 'DASHBOARD',\n      'projectsService': 'PROJECTS',\n      'reportsService': 'REPORTS',\n      'healthService': 'HEALTH',\n      'websocketService': 'WEBSOCKET',\n      'authService': 'AUTH',\n      'userService': 'USERS',\n      'mfaService': 'MFA',\n      'adminService': 'ADMIN',\n      'applicationSecurityService': 'APPLICATION_SECURITY'\n    };\n    const endpointGroup = serviceEndpointMap[serviceName];\n    if (!endpointGroup) {\n      return {};\n    }\n    return API_ENDPOINTS[endpointGroup] || {};\n  }\n\n  /**\n   * Generate comprehensive integration report\n   */\n  generateIntegrationReport(services, startTime) {\n    const totalEndpoints = services.reduce((sum, s) => sum + s.endpoints.length, 0);\n    const successfulEndpoints = services.reduce((sum, s) => sum + s.endpoints.filter(e => e.status === 'success').length, 0);\n    const failedEndpoints = totalEndpoints - successfulEndpoints;\n    const allResponseTimes = services.flatMap(s => s.endpoints.filter(e => e.responseTime > 0).map(e => e.responseTime));\n    const averageResponseTime = allResponseTimes.length > 0 ? allResponseTimes.reduce((sum, time) => sum + time, 0) / allResponseTimes.length : 0;\n    const overallHealth = successfulEndpoints / totalEndpoints >= 0.9 ? 'healthy' : successfulEndpoints / totalEndpoints >= 0.5 ? 'partial' : 'unhealthy';\n    return {\n      timestamp: new Date(),\n      overallHealth,\n      services,\n      summary: {\n        totalEndpoints,\n        successfulEndpoints,\n        failedEndpoints,\n        averageResponseTime\n      }\n    };\n  }\n\n  /**\n   * Get verification results for a specific service\n   */\n  getServiceVerificationResults(serviceName) {\n    return this.verificationResults.get(serviceName);\n  }\n\n  /**\n   * Get all verification results\n   */\n  getAllVerificationResults() {\n    return new Map(this.verificationResults);\n  }\n\n  /**\n   * Export verification report as JSON\n   */\n  exportVerificationReport() {\n    const report = {\n      timestamp: new Date().toISOString(),\n      services: Array.from(this.verificationResults.values())\n    };\n    return JSON.stringify(report, null, 2);\n  }\n\n  /**\n   * Get services that need attention\n   */\n  getServicesNeedingAttention() {\n    return Array.from(this.verificationResults.values()).filter(service => service.overallStatus === 'unhealthy' || service.overallStatus === 'partial');\n  }\n\n  /**\n   * Get overall system health percentage\n   */\n  getOverallSystemHealth() {\n    if (this.verificationResults.size === 0) return 0;\n    const totalServices = this.verificationResults.size;\n    const healthyServices = Array.from(this.verificationResults.values()).filter(service => service.overallStatus === 'healthy').length;\n    return healthyServices / totalServices * 100;\n  }\n}\n\n// Export singleton instance\nconst integrationVerificationService = new IntegrationVerificationService();\nexport default integrationVerificationService;","map":{"version":3,"names":["apiClient","apiCallWithRetry","API_ENDPOINTS","SERVICE_MAPPING","IntegrationVerificationService","constructor","verificationResults","Map","isVerifying","verifyAllIntegrations","Error","startTime","Date","now","services","Object","values","serviceResults","serviceName","serviceStatus","verifyServiceIntegration","push","set","report","generateIntegrationReport","endpoints","getServiceEndpoints","endpointResults","endpointName","endpoint","entries","result","testEndpoint","error","method","status","responseTime","message","successCount","filter","r","length","successRate","averageResponseTime","reduce","sum","overallStatus","service","lastVerified","statusCode","response","actualEndpoint","get","timeout","data","getError","_getError$response","post","postError","err","_err$response","code","serviceEndpointMap","endpointGroup","totalEndpoints","s","successfulEndpoints","e","failedEndpoints","allResponseTimes","flatMap","map","time","overallHealth","timestamp","summary","getServiceVerificationResults","getAllVerificationResults","exportVerificationReport","toISOString","Array","from","JSON","stringify","getServicesNeedingAttention","getOverallSystemHealth","size","totalServices","healthyServices","integrationVerificationService"],"sources":["D:/curser/copy-of-git-10-082025/cyber-cursor/frontend/src/services/integrationVerificationService.ts"],"sourcesContent":["import { apiClient, apiCallWithRetry } from '../utils/apiClient';\nimport { API_ENDPOINTS, SERVICE_MAPPING } from './integrationService';\n\n// Integration verification interfaces\nexport interface EndpointTestResult {\n  endpoint: string;\n  method: string;\n  status: 'success' | 'failed' | 'timeout' | 'unauthorized';\n  responseTime: number;\n  statusCode?: number;\n  error?: string;\n  response?: any;\n}\n\nexport interface ServiceIntegrationStatus {\n  service: string;\n  endpoints: EndpointTestResult[];\n  overallStatus: 'healthy' | 'partial' | 'unhealthy';\n  successRate: number;\n  averageResponseTime: number;\n  lastVerified: Date;\n}\n\nexport interface IntegrationReport {\n  timestamp: Date;\n  overallHealth: 'healthy' | 'partial' | 'unhealthy';\n  services: ServiceIntegrationStatus[];\n  summary: {\n    totalEndpoints: number;\n    successfulEndpoints: number;\n    failedEndpoints: number;\n    averageResponseTime: number;\n  };\n}\n\nclass IntegrationVerificationService {\n  private verificationResults: Map<string, ServiceIntegrationStatus> = new Map();\n  private isVerifying: boolean = false;\n\n  /**\n   * Verify all service integrations comprehensively\n   */\n  async verifyAllIntegrations(): Promise<IntegrationReport> {\n    if (this.isVerifying) {\n      throw new Error('Verification already in progress');\n    }\n\n    this.isVerifying = true;\n    const startTime = Date.now();\n\n    try {\n      const services = Object.values(SERVICE_MAPPING);\n      const serviceResults: ServiceIntegrationStatus[] = [];\n\n      for (const serviceName of services) {\n        const serviceStatus = await this.verifyServiceIntegration(serviceName);\n        serviceResults.push(serviceStatus);\n        this.verificationResults.set(serviceName, serviceStatus);\n      }\n\n      const report = this.generateIntegrationReport(serviceResults, startTime);\n      return report;\n    } finally {\n      this.isVerifying = false;\n    }\n  }\n\n  /**\n   * Verify integration for a specific service\n   */\n  async verifyServiceIntegration(serviceName: string): Promise<ServiceIntegrationStatus> {\n    const endpoints = this.getServiceEndpoints(serviceName);\n    const endpointResults: EndpointTestResult[] = [];\n\n    for (const [endpointName, endpoint] of Object.entries(endpoints)) {\n      try {\n        const result = await this.testEndpoint(endpoint, endpointName);\n        endpointResults.push(result);\n      } catch (error) {\n        endpointResults.push({\n          endpoint: endpointName,\n          method: 'GET',\n          status: 'failed',\n          responseTime: 0,\n          error: error instanceof Error ? error.message : 'Unknown error'\n        });\n      }\n    }\n\n    const successCount = endpointResults.filter(r => r.status === 'success').length;\n    const successRate = (successCount / endpointResults.length) * 100;\n    const averageResponseTime = endpointResults\n      .filter(r => r.responseTime > 0)\n      .reduce((sum, r) => sum + r.responseTime, 0) / successCount || 0;\n\n    const overallStatus = successRate >= 90 ? 'healthy' : \n                         successRate >= 50 ? 'partial' : 'unhealthy';\n\n    return {\n      service: serviceName,\n      endpoints: endpointResults,\n      overallStatus,\n      successRate,\n      averageResponseTime,\n      lastVerified: new Date()\n    };\n  }\n\n  /**\n   * Test a specific endpoint\n   */\n  private async testEndpoint(endpoint: string | ((id: string) => string), endpointName: string): Promise<EndpointTestResult> {\n    const startTime = Date.now();\n    let status: EndpointTestResult['status'] = 'success';\n    let statusCode: number | undefined;\n    let error: string | undefined;\n    let response: any;\n\n    try {\n      // Handle dynamic endpoints with IDs\n      const actualEndpoint = typeof endpoint === 'function' ? endpoint('test-id') : endpoint;\n      \n      // Test with GET method first, fallback to POST for endpoints that require it\n      try {\n        const result = await apiCallWithRetry(() => \n          apiClient.get(actualEndpoint, { timeout: 10000 })\n        );\n        statusCode = result.status;\n        response = result.data;\n      } catch (getError: any) {\n        if (getError.response?.status === 405) {\n          // Method not allowed, try POST\n          try {\n            const result = await apiCallWithRetry(() => \n              apiClient.post(actualEndpoint, {}, { timeout: 10000 })\n            );\n            statusCode = result.status;\n            response = result.data;\n          } catch (postError: any) {\n            throw postError;\n          }\n        } else {\n          throw getError;\n        }\n      }\n\n      if (statusCode >= 400) {\n        status = 'failed';\n        error = `HTTP ${statusCode}`;\n      }\n    } catch (err: any) {\n      if (err.code === 'ECONNABORTED') {\n        status = 'timeout';\n        error = 'Request timeout';\n      } else if (err.response?.status === 401) {\n        status = 'unauthorized';\n        error = 'Unauthorized access';\n      } else {\n        status = 'failed';\n        error = err.message || 'Request failed';\n      }\n    }\n\n    const responseTime = Date.now() - startTime;\n\n    return {\n      endpoint: endpointName,\n      method: 'GET',\n      status,\n      responseTime,\n      statusCode,\n      error,\n      response\n    };\n  }\n\n  /**\n   * Get all endpoints for a specific service\n   */\n  private getServiceEndpoints(serviceName: string): Record<string, string | ((id: string) => string)> {\n    // Map service names to their corresponding API endpoint groups\n    const serviceEndpointMap: Record<string, keyof typeof API_ENDPOINTS> = {\n      'sastService': 'SAST',\n      'dastService': 'DAST',\n      'raspService': 'RASP',\n      'cloudSecurityService': 'CLOUD_SECURITY',\n      'enhancedCloudSecurityService': 'ENHANCED_CLOUD_SECURITY',\n      'networkSecurityService': 'NETWORK_SECURITY',\n      'endpointSecurityService': 'ENDPOINT_SECURITY',\n      'endpointAntivirusEdrService': 'ENDPOINT_ANTIVIRUS_EDR',\n      'deviceControlService': 'DEVICE_CONTROL',\n      'dataSecurityService': 'DATA_SECURITY',\n      'dataProtectionService': 'DATA_PROTECTION',\n      'siemSoarService': 'SIEM_SOAR',\n      'monitoringSiemSoarService': 'MONITORING_SIEM_SOAR',\n      'analyticsService': 'ANALYTICS',\n      'threatIntelligenceService': 'THREAT_INTELLIGENCE',\n      'complianceService': 'COMPLIANCE',\n      'qualityGoalsService': 'QUALITY_GOALS',\n      'workflowsService': 'WORKFLOWS',\n      'incidentService': 'INCIDENTS',\n      'phishingService': 'PHISHING',\n      'cicdService': 'CICD',\n      'integrationsService': 'INTEGRATIONS',\n      'dashboardService': 'DASHBOARD',\n      'projectsService': 'PROJECTS',\n      'reportsService': 'REPORTS',\n      'healthService': 'HEALTH',\n      'websocketService': 'WEBSOCKET',\n      'authService': 'AUTH',\n      'userService': 'USERS',\n      'mfaService': 'MFA',\n      'adminService': 'ADMIN',\n      'applicationSecurityService': 'APPLICATION_SECURITY'\n    };\n\n    const endpointGroup = serviceEndpointMap[serviceName];\n    if (!endpointGroup) {\n      return {};\n    }\n\n    return API_ENDPOINTS[endpointGroup] || {};\n  }\n\n  /**\n   * Generate comprehensive integration report\n   */\n  private generateIntegrationReport(services: ServiceIntegrationStatus[], startTime: number): IntegrationReport {\n    const totalEndpoints = services.reduce((sum, s) => sum + s.endpoints.length, 0);\n    const successfulEndpoints = services.reduce((sum, s) => sum + s.endpoints.filter(e => e.status === 'success').length, 0);\n    const failedEndpoints = totalEndpoints - successfulEndpoints;\n    \n    const allResponseTimes = services.flatMap(s => s.endpoints.filter(e => e.responseTime > 0).map(e => e.responseTime));\n    const averageResponseTime = allResponseTimes.length > 0 ? \n      allResponseTimes.reduce((sum, time) => sum + time, 0) / allResponseTimes.length : 0;\n\n    const overallHealth = successfulEndpoints / totalEndpoints >= 0.9 ? 'healthy' :\n                         successfulEndpoints / totalEndpoints >= 0.5 ? 'partial' : 'unhealthy';\n\n    return {\n      timestamp: new Date(),\n      overallHealth,\n      services,\n      summary: {\n        totalEndpoints,\n        successfulEndpoints,\n        failedEndpoints,\n        averageResponseTime\n      }\n    };\n  }\n\n  /**\n   * Get verification results for a specific service\n   */\n  getServiceVerificationResults(serviceName: string): ServiceIntegrationStatus | undefined {\n    return this.verificationResults.get(serviceName);\n  }\n\n  /**\n   * Get all verification results\n   */\n  getAllVerificationResults(): Map<string, ServiceIntegrationStatus> {\n    return new Map(this.verificationResults);\n  }\n\n  /**\n   * Export verification report as JSON\n   */\n  exportVerificationReport(): string {\n    const report = {\n      timestamp: new Date().toISOString(),\n      services: Array.from(this.verificationResults.values())\n    };\n    return JSON.stringify(report, null, 2);\n  }\n\n  /**\n   * Get services that need attention\n   */\n  getServicesNeedingAttention(): ServiceIntegrationStatus[] {\n    return Array.from(this.verificationResults.values())\n      .filter(service => service.overallStatus === 'unhealthy' || service.overallStatus === 'partial');\n  }\n\n  /**\n   * Get overall system health percentage\n   */\n  getOverallSystemHealth(): number {\n    if (this.verificationResults.size === 0) return 0;\n    \n    const totalServices = this.verificationResults.size;\n    const healthyServices = Array.from(this.verificationResults.values())\n      .filter(service => service.overallStatus === 'healthy').length;\n    \n    return (healthyServices / totalServices) * 100;\n  }\n}\n\n// Export singleton instance\nconst integrationVerificationService = new IntegrationVerificationService();\nexport default integrationVerificationService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}